<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>User Exit Functions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 1.0.24" />
<meta name="description" content="This chapter explains how to use user exits to extend and customize the functionality of Oracle GoldenGate for HP NonStop on Guardian." />
<meta name="dcterms.created" content="2014-08-05T11:23:14Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="GoldenGate for Mainframe Reference Guide for HP NonStop (Guardian)" />
<meta name="dcterms.identifier" content="E28905-01" />
<meta name="dcterms.isVersionOf" content="GNSRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1995, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="measfls_measrpt_parameters.htm" title="Previous" type="text/html" />
<link rel="Next" href="event_messages.htm" title="Next" type="text/html" />
<link rel="alternate" href="E28905-01.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/13</span> <!-- End Header --><a id="i934904"></a>
<h1 class="chapter"><span class="secnum">8</span> User Exit Functions</h1>
<p>This chapter explains how to use user exits to extend and customize the functionality of Oracle GoldenGate for HP NonStop on Guardian.</p>
<p>This chapter includes:</p>
<ul>
<li>
<p><a href="#i934917">"Function summary"</a></p>
</li>
<li>
<p><a href="#i975374">"EXIT_CALL_RESULT"</a></p>
</li>
<li>
<p><a href="#i934980">"EXIT_CALL_TYPE"</a></p>
</li>
<li>
<p><a href="#i976208">"EXIT_PARAMS"</a></p>
</li>
<li>
<p><a href="#i935074">"EXIT_REC_BUF"</a></p>
</li>
<li>
<p><a href="#A1000838">"Calling environment functions"</a></p>
</li>
</ul>
<p>User exits extend and customize the functionality of the Extract and Replicat processing by calling COBOL, TAL or C routines from the Extract or Replicat parameter files. At different points during processing you can invoke custom COBOL, TAL or C routines to perform specialized functions.</p>
<p><span class="italic">Reference Guide for HP NonStop (Guardian)</span> supplies:</p>
<ul>
<li>
<p>Function parameters for accepting and processing different events and information from Extract or Replicat.</p>
</li>
<li>
<p>Calling environment functions, in TAL, C and COBOL, for retrieving context information from Extract or Replicat.</p>
</li>
</ul>
<p>Two example user exits are supplied with the installation code: <code>DEMOXCOB</code> (written in COBOL) and <code>DEMOXC</code> (written in C). You can use these exits as a sample to help plan your own user exit routines. Two blank user exit templates are also included: <code>USEREXC</code> for <code>C</code> and <code>USEREXT</code> for <code>TAL</code>. You can use these to start coding your routines. There is no sample for <code>TAL</code> and no template for <code>COBOL</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<p>User exits may be used for many kinds of routines; however, you should avoid controlling transaction commits with custom user exit logic. This could interfere with Oracle GoldenGate checkpoint processing, which facilitates troubleshooting and protects you in case of system failure.</p>
</div>
<a id="i934917"></a>
<div class="sect1">
<h2 class="sect1">Function summary</h2>
<p>Function parameters accept different events and information from the Extract or Replicat program, pass the information to the appropriate routine for processing and return a response and information to the caller.</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of user exit routines" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t3">Routine</th>
<th class="cellalignment21" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t3" headers="r1c1-t3">
<pre>
<a href="#i975374">EXIT_CALL_RESULT</a>
</pre></td>
<td class="cellalignment17" headers="r2c1-t3 r1c2-t3">
<p>Set by the user exit routines and tells the caller how to respond when each exit call completes.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t3" headers="r1c1-t3">
<pre>
<a href="#i934980">EXIT_CALL_TYPE</a>
</pre></td>
<td class="cellalignment17" headers="r3c1-t3 r1c2-t3">
<p>Indicates the processing point of the caller and determines the type of processing to perform.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t3" headers="r1c1-t3">
<pre>
<a href="#i976208">EXIT_PARAMS</a>
</pre></td>
<td class="cellalignment17" headers="r4c1-t3 r1c2-t3">
<p>Supplies information about the associated <code>EXIT_REC_BUF</code> when the call type is <code>PROCESS_RECORD</code> or <code>DISCARD_RECORD</code>. The exit routines can alter certain <code>EXIT_PARAMS</code> to change how the caller processes returned records.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t3" headers="r1c1-t3">
<pre>
<a href="#i935074">EXIT_REC_BUF</a>
</pre></td>
<td class="cellalignment17" headers="r5c1-t3 r1c2-t3">
<p>Contains the record about to be processed by Extract or Replicat. <code>EXIT_REC_BUF</code> is supplied when the call type is <code>PROCESS_RECORD</code> or <code>DISCARD_RECORD</code>. Exit routines can change the contents of this buffer, for example, to perform custom mapping functions.</p>
<p>When changing the contents of <code>EXIT_REC_BUF</code>, change the <code>SOURCE_FILE</code> (for Extract processing only) and <code>RECORD_LEN</code> parameters appropriately so that external processes can identify the record.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect1" -->
<a id="i975374"></a>
<div class="sect1">
<h2 class="sect1">EXIT_CALL_RESULT</h2>
<p><code>EXIT_CALL_RESULT</code> is set by the user exit routines and tells the caller how to respond when each exit call completes. The following results can be specified by the operator's routines.</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of the results from EXIT_CALL_RESULT" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t4">Result</th>
<th class="cellalignment21" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t4" headers="r1c1-t4">
<pre>
EXIT_ABEND_VAL
</pre></td>
<td class="cellalignment17" headers="r2c1-t4 r1c2-t4">
<p>Instructs the caller to <code>ABEND</code> immediately.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t4" headers="r1c1-t4">
<pre>
EXIT_IGNORE_VAL
</pre></td>
<td class="cellalignment17" headers="r3c1-t4 r1c2-t4">
<p>Reject records for further processing. <code>IGNORE</code> is appropriate when the exit performs all the desired processing on a record and there is no desire to output or replicate it.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t4" headers="r1c1-t4">
<pre>
EXIT_OK_VAL
</pre></td>
<td class="cellalignment17" headers="r4c1-t4 r1c2-t4">
<p>If the routine does nothing to respond to an event, <code>OK</code> is assumed. If the call specified <code>PROCESS-RECORD</code> or <code>DISCARD-RECORD</code> and <code>OK</code> is returned, the caller processes the record buffer returned by the user exit and uses the parameters set by the exit (see the <code>EXIT-REC-BUF</code> parameter for details).</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t4" headers="r1c1-t4">
<pre>
EXIT_STOP_VAL
</pre></td>
<td class="cellalignment17" headers="r5c1-t4 r1c2-t4">
<p>Instructs the caller to <code>STOP</code> immediately. <code>STOP</code> or <code>ABEND</code> may be appropriate when an error condition occurs in your program, such as a file error.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect1" -->
<a id="i934980"></a>
<div class="sect1">
<h2 class="sect1">EXIT_CALL_TYPE</h2>
<p><code>EXIT_CALL_TYPE</code> indicates the processing point of the caller and determines the type of processing to perform. Extract and Replicat use the following types of calls.</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of the types of calls that Extract and Replicat use with user exits" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t5">Call</th>
<th class="cellalignment21" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_BEGIN_TRANS
</pre></td>
<td class="cellalignment17" headers="r2c1-t5 r1c2-t5">
<p>In Extract, invoked just before the output of the first record in a transaction. In Replicat, invoked just before the start of a replicated transaction.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_DISCARD_RECORD
</pre></td>
<td class="cellalignment17" headers="r3c1-t5 r1c2-t5">
<p>Called when a record is discarded. Records can be discarded for several reasons, such as the changed record is out-of-sync with the current version of an SQL table.</p>
<p>When <code>DISCARD-RECORD</code> is specified, the associated buffer is passed and custom discard processing can be specified.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_END_TRANS
</pre></td>
<td class="cellalignment17" headers="r4c1-t5 r1c2-t5">
<p>In Extract and Replicat, invoked just after the last record in a transaction is processed.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_FILE_CLOSE
</pre></td>
<td class="cellalignment17" headers="r5c1-t5 r1c2-t5">
<p>Invoked by a direct read Extract when it closes the current data file.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r6c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_PROCESS_RECORD
</pre></td>
<td class="cellalignment17" headers="r6c1-t5 r1c2-t5">
<p>In Extract, invoked before a record buffer is output to a trail or file. In Replicat, invoked just before a Replicat operation is performed. This call is the basis of most user exit processing.</p>
<p>When a <code>PROCESS_RECORD</code> call is invoked, the record buffer and parameters describing the record are supplied to the user exit. You can map, transform, clean or perform virtually any other operation with the record. You can return a status indicating whether the caller should process or ignore the record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r7c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_START
</pre></td>
<td class="cellalignment17" headers="r7c1-t5 r1c2-t5">
<p>Invoked at the start of processing. The user exit can perform initialization work, such as opening files, initializing variables, and so forth.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r8c1-t5" headers="r1c1-t5">
<pre>
EXIT_CALL_STOP
</pre></td>
<td class="cellalignment17" headers="r8c1-t5 r1c2-t5">
<p>Invoked before the caller stops or ends abnormally. The user exit can perform completion work, such as closing files or outputting totals.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect1" -->
<a id="i976208"></a>
<div class="sect1">
<h2 class="sect1">EXIT_PARAMS</h2>
<p><code>EXIT_PARAMS</code> supply information about the associated <code>EXIT-REC-BUF</code> when the call type is <code>PROCESS_RECORD</code> or <code>DISCARD_RECORD</code>. The exit routines can alter certain <code>EXIT_PARAMS</code> to change how the caller processes returned records. The <code>EXIT_PARAMS</code> structure includes the following:</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of exit parameters that can be used to change how the caller processes returned records" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t6">Exit Parameter</th>
<th class="cellalignment21" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t6" headers="r1c1-t6">
<pre>
AUDIT_TIMESTAMP
</pre></td>
<td class="cellalignment17" headers="r2c1-t6 r1c2-t6">
<p>Provides the Julian, GMT timestamp of the audit block in which the record was found. This timestamp approximates the time of the original database operation.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t6" headers="r1c1-t6">
<pre>
BEFORE_AFTER_IND
</pre></td>
<td class="cellalignment17" headers="r3c1-t6 r1c2-t6">
<p>For update records, determines whether the record is a before-image (<code>B</code>) or after-image (<code>A</code>). When extracted, before-images precede after-images within the same update. Inserts are after-images, and deletes are before-images.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t6" headers="r1c1-t6">
<pre>
ERR_INFO
</pre></td>
<td class="cellalignment17" headers="r4c1-t6 r1c2-t6">
<p>This information is supplied with a discarded record to indicate the reason for the discard. The Oracle GoldenGate for Mainframe error number (<code>ERR_NUM</code>) is passed, along with a possible file or SQL error and error text.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t6" headers="r1c1-t6">
<pre>
FUNCTION_PARAM
</pre></td>
<td class="cellalignment17" headers="r5c1-t6 r1c2-t6">
<p>Lets you pass a parameter to the exit. This parameter is set up in the Extract or Replicat parameter file as part of the <code>FILE</code> or <code>MAP</code> parameter.</p>
<p>The default size of <code>EXIT_PARAMS</code> is 256 bytes. If the string supplied with the <code>EXITPARAM</code> parameter is shorter, it will be a NULL terminated string. Use the <code>GET_EXITPARAM_VALUE</code> function to access data over that length.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r6c1-t6" headers="r1c1-t6">
<pre>
MORE_RECS_IND
</pre></td>
<td class="cellalignment17" headers="r6c1-t6 r1c2-t6">
<p>Set by the user on return from an exit. For database records, determines whether Extract or Replicat processes the record again.</p>
<p>This allows the exit program, for example, to output many records per record processed by Extract, a common function when converting Enscribe to SQL (data normalization). To request the same record again, set <code>MORE_RECS_IND</code> to <code>Y</code>.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r7c1-t6" headers="r1c1-t6">
<pre>
RECORD_LEN
</pre></td>
<td class="cellalignment17" headers="r7c1-t6 r1c2-t6">
<p>Provides the length of the record buffer passed. Change <code>RECORD_LEN</code> if the Extract <code>SOURCE_FILE</code> parameter is altered to reflect the new length of the buffer.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r8c1-t6" headers="r1c1-t6">
<pre>
RECORD_TYPE
</pre></td>
<td class="cellalignment17" headers="r8c1-t6 r1c2-t6">
<p>Identifies the record as <code>SQL</code> or <code>ENS</code> for Enscribe.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r9c1-t6" headers="r1c1-t6">
<pre>
SOURCE_FILE
</pre></td>
<td class="cellalignment17" headers="r9c1-t6 r1c2-t6">
<p>Identifies the type of record passed to the exit during Extract processing. When custom mapping is performed, it is sometimes appropriate for the exit routines to change this field. For example, if the exit uses the record buffer from <code>$DATA5.FLS.ACCTFL</code> and changes it to the format of <code>$DATA6.TABS.ACCTTAB</code>, your exit should change <code>SOURCE_FILE</code> to <code>$DATA6.TABS.ACCTTAB</code>.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r10c1-t6" headers="r1c1-t6">
<pre>
UPDATE_TYPE
</pre></td>
<td class="cellalignment17" headers="r10c1-t6 r1c2-t6">
<p>Determines the type of operation associated with the record buffer. Operations types are:</p>
<ul>
<li>
<p><code>INSERT_IO</code></p>
<p>The record is an insert to the source file.</p>
</li>
<li>
<p><code>DELETE_IO</code></p>
<p>The record is a delete, and the buffer is the image of the record being deleted.</p>
</li>
<li>
<p><code>UPDATE_IO</code></p>
<p>The record is an update to the source file. The full after update image is supplied.</p>
</li>
<li>
<p><code>UPDATE_COMP_ENSCRIBE</code></p>
<p>The record is a compressed Enscribe update. Only primary key fields and changed fields are supplied. Routines are supplied to overlay each field in its corresponding uncompressed location.</p>
</li>
<li>
<p><code>UPDATE_COMP_PK_SQL_VAL</code></p>
<p>The record is a primary key update. It contains three parts in the data portion of the record: 1) the before-image key length, 2) the before-image key values in field comp format, and 3) the after-image in field comp format.</p>
</li>
<li>
<p><code>UPDATE_COMP_SQL</code></p>
<p>The record is a compressed SQL update. Only primary key fields and changed fields are supplied. Routines are supplied to overlay each field in its corresponding uncompressed location.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect1" -->
<a id="i935074"></a>
<div class="sect1">
<h2 class="sect1">EXIT_REC_BUF</h2>
<p><code>EXIT_REC_BUF</code> contains the record about to be processed and is supplied when the call type is <code>PROCESS_RECORD</code> or <code>DISCARD_RECORD</code>. Exit routines can change the contents of this buffer, for example, to perform custom mapping functions. When changing the contents of <code>EXIT_REC_BUF</code>, change the <code>SOURCE_FILE</code> (for Extract only) and <code>RECORD_LEN</code> parameters appropriately so that external processes can identify the record.</p>
</div>
<!-- class="sect1" -->
<a id="A1000838"></a>
<div class="sect1">
<h2 class="sect1">Calling environment functions</h2>
<p>Environment functions are routines the exit can call to retrieve context information from Extract or Replicat. These functions are summarized below and each of the functions is explained in more detail in the remainder of the chapter. Syntax examples are included for <code>C</code>, <code>TAL</code>, and <code>COBOL</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<p>Each <code>COBOL</code> syntax section documents the <code>?CONSULT =EXTRACT (or =REPLICAT)</code> compiler directive. Actually, this directive is declared only once no matter how many functions are called in the user exit. Make sure it points to the correct object type, which will be Extract for an Extract user exit, Replicat for a <code>TNS</code> Replicat user exit or <code>REPR</code> for native relinkable Replicat user exit.</p>
</div>
<p class="subhead2"><a id="sthref1726"></a>Function Summary</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of functions used by user exits" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t8">Function</th>
<th class="cellalignment21" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t8" headers="r1c1-t8">
<pre>
<a href="#i967707">COMPRESS_RECORD | COMPRESS_RECORD2</a>
</pre></td>
<td class="cellalignment17" headers="r2c1-t8 r1c2-t8">
<p>Use when some of a target table's columns are present after mapping. Typically, use in conjunction with <code>DECOMPRESS_RECORD</code>.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t8" headers="r1c1-t8">
<pre>
<a href="#i970554">DECOMPRESS_RECORD | DECOMPRESS_RECORD2</a>
</pre></td>
<td class="cellalignment17" headers="r3c1-t8 r1c2-t8">
<p>Makes compressed SQL updates easier to process and map.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t8" headers="r1c1-t8">
<pre>
<a href="#i965153">FETCH_CURRENT_RECORD</a>
</pre></td>
<td class="cellalignment17" headers="r4c1-t8 r1c2-t8">
<p>Obtains the current Enscribe key-sequenced or entry-sequenced target record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t8" headers="r1c1-t8">
<pre>
<a href="#i954298">FETCH_CURRENT_RECORD_WITH_LOCK</a>
</pre></td>
<td class="cellalignment17" headers="r5c1-t8 r1c2-t8">
<p>Obtains the current Enscribe key-sequenced or entry-sequenced target record while locking the record for update.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r6c1-t8" headers="r1c1-t8">
<pre>
<a href="#i968264">GET_ALTKEY_INFO</a>
</pre></td>
<td class="cellalignment17" headers="r6c1-t8 r1c2-t8">
<p>Returns information on a file's alternate key.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r7c1-t8" headers="r1c1-t8">
<pre>
<a href="#i968268">GET_COLUMN_INDEX</a>
</pre></td>
<td class="cellalignment17" headers="r7c1-t8 r1c2-t8">
<p>Given a column name, returns the column index number.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r8c1-t8" headers="r1c1-t8">
<pre>
<a href="#i935358">GET_COLUMN_NAME</a>
</pre></td>
<td class="cellalignment17" headers="r8c1-t8 r1c2-t8">
<p>Given a column index, returns the column's name.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r9c1-t8" headers="r1c1-t8">
<pre>
<a href="#i935373">GET_ENV_VALUE</a>
</pre></td>
<td class="cellalignment17" headers="r9c1-t8 r1c2-t8">
<p>Returns the source or target file name in internal or external format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r10c1-t8" headers="r1c1-t8">
<pre>
<a href="#i978092">GET_EXTRBA</a>
</pre></td>
<td class="cellalignment17" headers="r10c1-t8 r1c2-t8">
<p>Gets the current position in the extract trail.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r11c1-t8" headers="r1c1-t8">
<pre>
<a href="#i966461">GET_EXTSEQNO</a>
</pre></td>
<td class="cellalignment17" headers="r11c1-t8 r1c2-t8">
<p>Gets the sequence number of the current extract trail.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r12c1-t8" headers="r1c1-t8">
<pre>
<a href="field_conversion_functions.htm#i935422">DATEDIFF</a>
</pre></td>
<td class="cellalignment17" headers="r12c1-t8 r1c2-t8">
<p>Retrieves the source or target file name.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r13c1-t8" headers="r1c1-t8">
<pre>
<a href="#i968480">GET_FOPEN_NUM</a>
</pre></td>
<td class="cellalignment17" headers="r13c1-t8 r1c2-t8">
<p>Gets the open number of the current file.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r14c1-t8" headers="r1c1-t8">
<pre>
<a href="#i966839">GET_NUM_COLUMNS</a>
</pre></td>
<td class="cellalignment17" headers="r14c1-t8 r1c2-t8">
<p>Returns the number of columns.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r15c1-t8" headers="r1c1-t8">
<pre>
<a href="#i935455">GET_RECORD | GET_RECORD2</a>
</pre></td>
<td class="cellalignment17" headers="r15c1-t8 r1c2-t8">
<p>Use for custom field conversions that may not be handled by Extract or Replicat.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r16c1-t8" headers="r1c1-t8">
<pre>
<a href="#i935484">GET_RECORD_LENGTH | GET_RECORD_LENGTH2</a>
</pre></td>
<td class="cellalignment17" headers="r16c1-t8 r1c2-t8">
<p>Retrieves the length of the target record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r17c1-t8" headers="r1c1-t8">
<pre>
<a href="#i939962">GET_SYSKEY_LENGTH</a>
</pre></td>
<td class="cellalignment17" headers="r17c1-t8 r1c2-t8">
<p>Retrieves the SYSKEY length for the current record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r18c1-t8" headers="r1c1-t8">
<pre>
<a href="#i935512">GET_TRANSACTION_IND</a>
</pre></td>
<td class="cellalignment17" headers="r18c1-t8 r1c2-t8">
<p>Supplies a data records position in a transaction, such as first, last, or middle.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r19c1-t8" headers="r1c1-t8">
<pre>
<a href="#i977439">GET_USER_TOKEN_VALUE</a>
</pre></td>
<td class="cellalignment17" headers="r19c1-t8 r1c2-t8">
<p>Allows user to retrieve the value of a user token.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r20c1-t8" headers="r1c1-t8">
<pre>
<a href="#i977237">GGS_EMSMESSAGE</a>
</pre></td>
<td class="cellalignment17" headers="r20c1-t8 r1c2-t8">
<p>Allows a user exit to write an EMS message.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r21c1-t8" headers="r1c1-t8">
<pre>
<a href="#i947082">GGS_REPORTMESSAGE</a>
</pre></td>
<td class="cellalignment17" headers="r21c1-t8 r1c2-t8">
<p>Allows a user exit to write to the report file.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r22c1-t8" headers="r1c1-t8">
<pre>
<a href="#BABJIFFD">SET_TARGET_RECORD2</a>
</pre></td>
<td class="cellalignment17" headers="r22c1-t8 r1c2-t8">
<p>Sets the values of a modified record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r23c1-t8" headers="r1c1-t8">
<pre>
<a href="#BABHHGBE">SET_TARGET_RECORD_LENGTH2</a>
</pre></td>
<td class="cellalignment17" headers="r23c1-t8 r1c2-t8">
<p>Sets the length of a modified record.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" -->
<p class="subhead2"><a id="sthref1727"></a>The function RESULT</p>
<p>The <code>RESULT</code> value returned by each function indicates whether or not the function was successful. Possible values are listed below, but different functions may be limited in those they will use.</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and discription of return values results" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t9">Return value</th>
<th class="cellalignment21" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t9" headers="r1c1-t9">
<pre>
EXIT_ENV_SOURCE_FILE
</pre></td>
<td class="cellalignment17" headers="r2c1-t9 r1c2-t9">
<p>Indicates the 24-byte internal format source file name.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t9" headers="r1c1-t9">
<pre>
EXIT_ENV_SOURCE_FILE_EXT
</pre></td>
<td class="cellalignment17" headers="r3c1-t9 r1c2-t9">
<p>Indicates the source file name in external format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t9" headers="r1c1-t9">
<pre>
EXIT_ENV_TARGET_FILE
</pre></td>
<td class="cellalignment17" headers="r4c1-t9 r1c2-t9">
<p>Indicates the target file name in internal format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t9" headers="r1c1-t9">
<pre>
EXIT_ENV_TARGET_FILE_EXT
</pre></td>
<td class="cellalignment17" headers="r5c1-t9 r1c2-t9">
<p>Indicates the target file name in external format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r6c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_OK
</pre></td>
<td class="cellalignment17" headers="r6c1-t9 r1c2-t9">
<p>Function succeeded.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r7c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_FETCH-ERROR
</pre></td>
<td class="cellalignment17" headers="r7c1-t9 r1c2-t9">
<p>An error occurred when attempting to fetch a record.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r8c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_INVALID_COLUMN
</pre></td>
<td class="cellalignment17" headers="r8c1-t9 r1c2-t9">
<p>A non-existent column was referred to in the function call.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r9c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_INVALID_CONTEXT
</pre></td>
<td class="cellalignment17" headers="r9c1-t9 r1c2-t9">
<p>Function called at improper time.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r10c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_NOT_SUPPORTED
</pre></td>
<td class="cellalignment17" headers="r10c1-t9 r1c2-t9">
<p>The request is not supported.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r11c1-t9" headers="r1c1-t9">
<pre>
EXIT_FN_RET_INVALID_PARAM
</pre></td>
<td class="cellalignment17" headers="r11c1-t9 r1c2-t9">
<p>An invalid parameter was passed to the function.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" -->
<p class="subhead2"><a id="sthref1728"></a>User exit libraries</p>
<p>Three copy libraries define error codes, constants, and structures that are passed to and from the user exits. <code>C</code> user exits should use <code>XLIBC and TAL</code> should use <code>XLIBTAL.</code> For <code>COBOL</code> the library is <code>XLIBCOB</code>.</p>
<p>The function prototypes for <code>C</code> user exits are defined in the library <code>usrdecs</code>. For <code>TAL</code> the library is <code>usrdect</code>. These should be included in the user exit routine.</p>
</div>
<!-- class="sect1" -->
<a id="i967707"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">COMPRESS_RECORD | COMPRESS_RECORD2</h2>
<p>Use <code>COMPRESS_RECORD</code> after processing a decompressed record. <code>DECOMPRESS_RECORD</code> is typically invoked when missing column values need to be fetched, such as before mapping a compressed update. <code>COMPRESS_RECORD</code> is called after the mapping or other processing has been completed.</p>
<p>In a C program, precede the <code>INVOKE</code> statement by the <code>#pragma</code> <code>SQL</code> <code>CHAR_AS_ARRAY</code>.</p>
<p><code>COMPRESS_RECORD</code> is only valid for use with records that are less than 32767. <code>COMPRESS_RECORD2</code> is valid for both these shorter records and the longer records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1729"></a>Syntax COMPRESS_RECORD</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *compressed_rec;
short    compressed_len;
char     *decompressed_rec;
short    *columns_present;
short    source_or_target;
short    result;
result = COMPRESS_RECORD (compressed_rec, compressed_len, decompressed_rec,
                          columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext compressed_rec;
int    .ext compressed_len;
string .ext decompressed_rec;
int    .ext columns_present;
int     source_or_target;
result := COMPRESS_RECORD (compressed_rec, compressed_len, decompressed_rec,
                            columns_present, source_or_target) ;
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 compressed-rec   PIC X(32767).
01 compressed-len   PIC S9(4) COMP.
01 decompressed-rec PIC X(32767).
01 columns-present  PIC S9(4) COMP OCCURS 2000 TIMES.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "COMPRESS_RECORD" using compressed-rec, compressed-len, 
         decompressed-rec, columns-present, source-or-target giving result.
</pre>
<dl>
<dt><code>columns_present</code></dt>
<dt><code>columns-present</code></dt>
<dd>
<p>An array indicating which columns to compress. For example, if the first, third and sixth columns are to be compressed, and the total number of columns is seven, the columns array should contain <code>1,0,1,0,0,1,0</code>. The number of columns in the table can be obtained by <code>GET_NUM_COLUMNS</code>. A column that is present but set to <code>NULL</code> should be indicated by a <code>1</code>.</p>
</dd>
<dt><code>compressed_len</code></dt>
<dt><code>compress-len</code></dt>
<dd>
<p>The returned length of the compressed record.</p>
</dd>
<dt><code>compressed_rec</code></dt>
<dt><code>compressed-rec</code></dt>
<dd>
<p>The record returned in compressed format. The size is allocated by the user up to the maximum of 32767.</p>
</dd>
<dt><code>decompressed_rec</code></dt>
<dt><code>decompressed-rec</code></dt>
<dd>
<p>The record after it has been decompressed. The size is allocated by the user up to the maximum of 32767.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
</dl>
<p class="titleinrefsubsect"><a id="sthref1730"></a>Syntax COMPRESS_RECORD2</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *compressed_rec;
long     compressed_len;
char     *decompressed_rec;
short    *columns_present;
short    source_or_target;
short    result;
result = COMPRESS_RECORD2 (compressed_rec, compressed_len, decompressed_rec,
                          columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext compressed_rec;
int(32).ext compressed_len;
string .ext decompressed_rec;
int    .ext columns_present;
int     source_or_target;
result := COMPRESS_RECORD2 (compressed_rec, compressed_len, decompressed_rec,
                            columns_present, source_or_target) ;
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 compressed-rec   PIC X(128000).
01 compressed-len   PIC S9(8) COMP.
01 decompressed-rec PIC X(128000).
01 columns-present  PIC S9(4) COMP OCCURS 2000 TIMES.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "COMPRESS_RECORD2" using compressed-rec, compressed-len, 
         decompressed-rec, columns-present, source-or-target giving result.
</pre>
<dl>
<dt><code>columns_present</code></dt>
<dt><code>columns-present</code></dt>
<dd>
<p>An array indicating which columns to compress. For example, if the first, third and sixth columns are to be compressed, and the total number of columns is seven, the columns array should contain <code>1,0,1,0,0,1,0</code>. The number of columns in the table can be obtained by <code>GET_NUM_COLUMNS</code>. A column that is present but set to <code>NULL</code> should be indicated by a <code>1</code>.</p>
</dd>
<dt><code>compressed_len</code></dt>
<dt><code>compress-len</code></dt>
<dd>
<p>The returned length of the compressed record.</p>
</dd>
<dt><code>compressed_rec</code></dt>
<dt><code>compressed-rec</code></dt>
<dd>
<p>The record returned in compressed format. Up to <code>X(128000)</code> can be allocated by the user as long as it is declared in extended storage.</p>
</dd>
<dt><code>decompressed_rec</code></dt>
<dt><code>decompressed-rec</code></dt>
<dd>
<p>The record after it has been decompressed. Up to <code>X(128000)</code> can be allocated by the user as long as it is declared in extended storage.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i970554"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">DECOMPRESS_RECORD | DECOMPRESS_RECORD2</h2>
<p><code>DECOMPRESS_RECORD</code> makes compressed update records easier to process and map. Typically, <code>DECOMPRESS_RECORD</code> is invoked before mapping a compressed update to trigger fetching of missing column values. <code>COMPRESS_RECORD</code> is called after processing the compressed updates.</p>
<p>In a C program, precede the <code>INVOKE</code> statement by the <code>#pragma SQL CHAR_AS_ARRAY.</code> Within this structure there may be one or more columns without any true values. Valid columns are indicated in the <code>COLUMNS-PRESENT</code> array.</p>
<p><code>DECOMPRESS_RECORD</code> is only valid for use with records that are less than 32767. <code>DECOMPRESS_RECORD2</code> is valid for both these shorter records and the longer records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1731"></a>Syntax DECOMPRESS_RECORD</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *compressed_rec;
short    compressed_len;
char     *decompressed_rec;
short    *columns_present;
short    source_or_target;
short    result;
result = DECOMPRESS_RECORD (compressed_rec, compressed_len, decompressed_rec,
                            columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext compressed_rec;
int    .ext compressed_len;
string .ext decompressed_rec;
int    .ext columns_present;
int     source_or_target; 
result := DECOMPRESS_RECORD (compressed_rec, compressed_len,
                         decompressed_rec, columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 compressed-rec         PIC X(32767).
01 compressed-len         PIC S9(4) COMP.
01 decompressed-rec       PIC X(32767).
01 columns-present.
  05 columns-present-flag PIC S9(4) COMP OCCURS 2000 TIMES.
01 source-or-target       PIC S9(4) COMP.
01 result                 PIC S9(4) COMP.
ENTER C "DECOMPRESS_RECORD" using compressed-rec, compressed-len,
          decompressed-rec, columns-present, source-or-target giving result.
</pre>
<dl>
<dt><code>columns_present</code></dt>
<dt><code>columns-present</code></dt>
<dd>
<p>An array of values that indicate the columns present in the compressed record. For example, if the first, third and sixth columns exist in the compressed record, and the total number of columns is seven, the array should contain <code>1,0,1,0,0,1,0</code>. The number of columns in the table can be obtained by <code>GET_NUM_COLUMNS</code>. A column that is present but set to <code>NULL</code> should be indicated by a <code>1</code>.</p>
</dd>
<dt><code>compressed_len</code></dt>
<dt><code>compressed-len</code></dt>
<dd>
<p>The length of the compressed record.</p>
</dd>
<dt><code>compressed_rec</code></dt>
<dt><code>compressed-rec</code></dt>
<dd>
<p>The record in compressed format. The size is allocated by the user up to the maximum of 32767.</p>
</dd>
<dt><code>decompressed_rec</code></dt>
<dt><code>decompressed-rec</code></dt>
<dd>
<p>The record returned in decompressed format. The size is allocated by the user up to the maximum of 32767</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
</dl>
<p class="titleinrefsubsect"><a id="sthref1732"></a>Syntax DECOMPRESS_RECORD2</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *compressed_rec;
long     compressed_len;
char     *decompressed_rec;
short    *columns_present;
short    source_or_target;
short    result;
result = DECOMPRESS_RECORD2 (compressed_rec, compressed_len, decompressed_rec,
                            columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext compressed_rec;
int(32).ext compressed_len;
string .ext decompressed_rec;
int    .ext columns_present;
int     source_or_target; 
result := DECOMPRESS_RECORD2 (compressed_rec, compressed_len,
                         decompressed_rec, columns_present, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 compressed-rec         PIC X(128000).
01 compressed-len         PIC S9(8) COMP.
01 decompressed-rec       PIC X(128000).
01 columns-present.
  05 columns-present-flag PIC S9(4) COMP OCCURS 2000 TIMES.
01 source-or-target       PIC S9(4) COMP.
01 result                 PIC S9(4) COMP.
ENTER C "DECOMPRESS_RECORD2" using compressed-rec, compressed-len,
          decompressed-rec, columns-present, source-or-target giving result.
</pre>
<dl>
<dt><code>columns_present</code></dt>
<dt><code>columns-present</code></dt>
<dd>
<p>An array of values that indicate the columns present in the compressed record. For example, if the first, third and sixth columns exist in the compressed record, and the total number of columns is seven, the array should contain <code>1,0,1,0,0,1,0</code>. The number of columns in the table can be obtained by <code>GET_NUM_COLUMNS</code>. A column that is present but set to <code>NULL</code> should be indicated by a <code>1</code>.</p>
</dd>
<dt><code>compressed_len</code></dt>
<dt><code>compressed-len</code></dt>
<dd>
<p>The length of the compressed record.</p>
</dd>
<dt><code>compressed_rec</code></dt>
<dt><code>compressed-rec</code></dt>
<dd>
<p>The record in compressed format. Up to <code>X(128000)</code> can be allocated by the user as long as it is declared in extended storage.</p>
</dd>
<dt><code>decompressed_rec</code></dt>
<dt><code>decompressed-rec</code></dt>
<dd>
<p>The record returned in decompressed format. Up to <code>X(128000)</code> can be allocated by the user as long as it is declared in extended storage.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i965153"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">FETCH_CURRENT_RECORD</h2>
<p>Use the <code>FETCH_CURRENT_RECORD</code> function to get the record from the target table with the same key as the current source record without locking the record. This makes the record buffer available to be read into the user exit by completing a call to <code>GET_RECORD</code> for the target image.</p>
<p><code>FETCH_CURRENT_RECORD</code> is supported only for key-sequenced and entry-sequenced Enscribe files. The implementation for entry-sequenced files requires the use of a specified <code>ALTKEY</code> for proper positioning.</p>
<p>Fetching from the target table is only supported by Replicat, and only if a mapped target buffer is available. Replicat fetches the current record by key.</p>
<p class="titleinrefsubsect"><a id="sthref1733"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short     result;
typedef struct {
  long error_num; 
  char error_msg [600];
  long max_length; 
  long actual_length;
  short msg_truncated;
} error_info_def;
error_info_def error_info_ptr;
result = FETCH_CURRENT_RECORD (&amp;error_info_ptr);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext error_info_ptr(error_info_def);
result := FETCH_CURRENT_RECORD(error_info_ptr);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =REPLICAT
01 result          PIC S9(4) COMP.
01 error-info.
  02 error-num     PIC S9(4) COMP.
  02 error-msg     PIC X(600).
  02 max-length    PIC S9(4) COMP.
  02 actual-length PIC S9(4) COMP.
  02 msg-truncated PIC S9(4) COMP.
ENTER C "FETCH_CURRENT_RECORD" using error-info giving result.
</pre>
<dl>
<dt><code>actual-length</code></dt>
<dd>
<p>The actual length of the error message that is included.</p>
</dd>
<dt><code>error-msg</code></dt>
<dd>
<p>The message explaining the error. The size is set when the function is used. <code>PIC X(600)</code> and <code>char [600]</code> are only examples of a possible value.</p>
</dd>
<dt><code>error-num</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>max-length</code></dt>
<dd>
<p>The maximum length allowed for an error message.</p>
</dd>
<dt><code>msg-truncated</code></dt>
<dd>
<p>Indicates whether the error message has been truncated.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i954298"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">FETCH_CURRENT_RECORD_WITH_LOCK</h2>
<p>Use <code>FETCH_CURRENT_RECORD_WITH_LOCK</code> to get the record from the target table with the same key as the current source record, locking the record for update. This makes the record buffer available to be read into the user exit by completing a call to <code>GET_RECORD</code> for the target image.</p>
<p><code>FETCH_CURRENT_RECORD_WITH_LOCK</code> is supported only for key-sequenced and entry-sequenced Enscribe files. The implementation for entry-sequenced files requires the use of a specified <code>ALTKEY</code> for proper positioning. The use of <code>FETCH_CURRENT_RECORD_WITH_LOCK</code> is not recommended for inserts into entry-sequenced files.</p>
<p>Fetching from the target table is only supported by Replicat, and only if a mapped target buffer is available. Replicat fetches the current record by key.</p>
<p class="titleinrefsubsect"><a id="sthref1734"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short     result;
typedef struct {
  long error_num; 
  char error_msg;
  long max_length; 
  long actual_length;
  short msg_truncated;
} error_info_def;
error_info_def error_info_ptr;
result = FETCH_CURRENT_RECORD_WITH_LOCK(&amp;error_info_ptr);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext error_info_ptr(error_info_def);
result := FETCH_CURRENT_RECORD_WITH_LOCK(error_info_ptr);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =REPLICAT
01 result          PIC S9(4) COMP.
01 error-info.
  02 error-num     PIC S9(4) COMP.
  02 error-msg     PIC X(600).
  02 max-length    PIC S9(4) COMP.
  02 actual-length PIC S9(4) COMP.
  02 msg-truncated PIC S9(4) COMP.
ENTER C "FETCH_CURRENT_RECORD" using error-info giving result.
</pre>
<dl>
<dt><code>actual-length</code></dt>
<dd>
<p>The actual length of the error message that is included.</p>
</dd>
<dt><code>error-msg</code></dt>
<dd>
<p>The message explaining the error. The size is set when the function is used. <code>PIC X(600)</code> is only an example of a possible value.</p>
</dd>
<dt><code>error_num</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
<dt><code>max-length</code></dt>
<dd>
<p>The maximum length allowed for an error message.</p>
</dd>
<dt><code>msg-truncated</code></dt>
<dd>
<p>Indicates whether the error message has been truncated.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i968264"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_ALTKEY_INFO</h2>
<p>Returns information about an alternate key.</p>
<p class="titleinrefsubsect"><a id="sthref1735"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
short  result;
short  keytag;
short  keyoff;
short  keylen;
result = GET_ALTKEY_INFO (&amp;keytag, &amp;keyoff, &amp;keylen);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext keytag;
int .ext keyoff;
int .ext keylen;
result := GET_ALTKEY_INFO(keytag, keyoff, keylen);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result PIC S9(4) COMP.
01 keytag PIC S9(4) COMP.
01 keyoff PIC S9(4) COMP.
01 keylen PIC S9(4) COMP.
ENTER C "GET_ALTKEY_INFO" using keytag, keyoff, keylen giving result.
</pre>
<dl>
<dt><code>keytag</code></dt>
<dd>
<p>The two-byte, generally alphanumeric, code that identifies the alternate key.</p>
</dd>
<dt><code>keyoff</code></dt>
<dd>
<p>The offset of the alternate key.</p>
</dd>
<dt><code>keylen</code></dt>
<dd>
<p>The length of the alternate key.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i968268"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_COLUMN_INDEX</h2>
<p>Given a column name, returns the column index number.</p>
<p class="titleinrefsubsect"><a id="sthref1736"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    result, 
short    col_idx;
char     col_name[36];
short    source_or_target;
result = GET_COLUMN_INDEX(&amp;col_idx, col_name, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int    .ext col_idx;
string .ext col_name;
int     source_or_target;
result := GET_COLUMN_INDEX (col_idx, col_name, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result            PIC S9(4) COMP.
01 col-idx           PIC S9(4) COMP.
01 col-name          PIC X(36).
01 source-or-target  PIC S9(4) COMP.
ENTER C "GET_COLUMN_INDEX" using col-idx, col-name, source_or_target,
                           giving result. 
</pre>
<dl>
<dt><code>col_idx</code></dt>
<dt><code>col-idx</code></dt>
<dd>
<p>A sequential number from 0 to (number of columns - 1) that identifies a column.</p>
</dd>
<dt><code>col_name</code></dt>
<dt><code>col-name</code></dt>
<dd>
<p>The name of the column from the SQL catalog.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i935358"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_COLUMN_NAME</h2>
<p>Given a column index, returns the name.</p>
<p class="titleinrefsubsect"><a id="sthref1737"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    result;
short    col_idx;
char     col_name[36];
short    max_name_len, 
short    source_or_target;
result = GET_COLUMN_NAME(col_idx, col_name, max_name_len, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int     col_idx;
string .ext column_name;
int     max_name_len;
int     source_or_target;
result := GET_COLUMN_NAME (col_idx, col_name, max_name_len,
                           source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result       PIC S9(4) COMP.
01 col-idx      PIC S9(4) COMP.
01 col-name     PIC x(36).
01 max-name-len PIC S9(4) COMP.
ENTER C "GET_COLUMN_NAME" using col-idx, col-name, max-name-len, 
                          source-or-target giving result.
</pre>
<dl>
<dt><code>col_idx</code></dt>
<dt><code>col-idx</code></dt>
<dd>
<p>A sequential number from 0 to (number of columns - 1) that identifies a column.</p>
</dd>
<dt><code>col_name</code></dt>
<dt><code>col-name</code></dt>
<dd>
<p>The name of the column.</p>
</dd>
<dt><code>max_name_len</code></dt>
<dd>
<p>The maximum length of the returned column name.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i935373"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_ENV_VALUE</h2>
<p>Returns the file name of the source or target file in either internal or external format.</p>
<p>For a successful completion, the type of value is indicated in the result code by one following:</p>
<div class="inftblhruleinformal">
<table class="cellalignment20" summary="This table lists the name and meaning of result codes returned from GET_ENV_VALUE" dir="ltr">
<thead>
<tr class="cellalignment11">
<th class="cellalignment21" id="r1c1-t10">Result Code</th>
<th class="cellalignment21" id="r1c2-t10">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment11">
<td class="cellalignment17" id="r2c1-t10" headers="r1c1-t10">
<pre>
EXIT_ENV_SOURCE_FILE
</pre></td>
<td class="cellalignment17" headers="r2c1-t10 r1c2-t10">
<p>Return value is the source file name in internal format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r3c1-t10" headers="r1c1-t10">
<pre>
EXIT_ENV_SOURCE_FILE_EXT
</pre></td>
<td class="cellalignment17" headers="r3c1-t10 r1c2-t10">
<p>Return value is the source file name in external format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r4c1-t10" headers="r1c1-t10">
<pre>
EXIT_ENV_TARGET_FILE
</pre></td>
<td class="cellalignment17" headers="r4c1-t10 r1c2-t10">
<p>Return value is the target file name in internal format.</p>
</td>
</tr>
<tr class="cellalignment11">
<td class="cellalignment17" id="r5c1-t10" headers="r1c1-t10">
<pre>
EXIT_ENV_TARGET_FILE_EXT
</pre></td>
<td class="cellalignment17" headers="r5c1-t10 r1c2-t10">
<p>Return value is the target file name in external format.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" -->
<p class="titleinrefsubsect"><a id="sthref1738"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    result;
short    source_or_target;
char     buf[100];
long     actuallen; 
long     maxlen;
short    truncated;
result = GET_ENV_VALUE (source_or_target, &amp;buf, &amp;maxlen, &amp;actuallen,
                         &amp;truncated);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int     result;
int     source_or_target;
string  .ext buf;
int(32) maxlen;
int(32) .ext actuallen;
int     .ext truncated;
result :=  GET_ENV_VALUE(source_or_target, buf, maxlen, actuallen, 
                         truncated);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result           PIC S9(4) COMP.
01 source-or-target PIC S9(4) COMP.
01 buf              PIC X(100).
01 maxlen           PIC S9(8) COMP.
01 actuallen        PIC S9(8) COMP.
01 truncated        PIC S9(4) COMP.
ENTER C "GET_ENV_VALUE" using source-or-target, buf, maxlen, actuallen,
                         truncated giving result.
</pre>
<dl>
<dt><code>actuallen</code></dt>
<dd>
<p>The actual length of the returned buffer</p>
</dd>
<dt><code>buf</code></dt>
<dd>
<p>The character buffer that will receive data. The space is allocated when the function is used. <code>PIC X(100)</code> and <code>char buf[100]</code> are only examples of a possible value.</p>
</dd>
<dt><code>maxlen</code></dt>
<dd>
<p>The maximum size that was allocated to the buffer.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
<dt><code>truncated</code></dt>
<dd>
<p>Indicates whether the returned data has been truncated.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<hr />
<div class="refsect1"><a id="sthref1739"></a>
<h2 class="refsect1">GET_EXITPARAM_VALUE</h2>
<p>Use to access the full value of the <code>EXITPARAM</code> string. (<code>FUNCTION_PARAM</code> of <code>EXIT_PARAMS</code> will only provide up to 256 bytes of any <code>EXITPARAM</code>.)</p>
<p class="titleinrefsubsect"><a id="sthref1740"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char      *exit_parm;
short     len;
short     result;
result = GET_EXITPARAM_VALUE (exit_parm, &amp;len));
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext exit_parm;
int .ext5 len;
result := GET_EXITPARAM_VALUE (exit_parm, len);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or = REPLICAT)
01 EXIT-PARM PIC X(1000).
01 LEN       PIC S9(4) COMP.
01 RESULT    PIC S9(4) COMP.
ENTER C"GET_EXITPARAM_VALUE" using exit_parm, len giving result.
</pre>
<dl>
<dt><code>exit_parm</code></dt>
<dt><code>exit-parm</code></dt>
<dd>
<p>The length of the buffer. This is defined by the user.</p>
</dd>
<dt><code>len</code></dt>
<dd>
<p>The maximum size that was allocated to the buffer.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i978092"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_EXTRBA</h2>
<p>Gets the current position in the Oracle GoldenGate trail.</p>
<p class="titleinrefsubsect"><a id="sthref1741"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
long long extrba;
short     result;
result = GET_EXTRBA(&amp;extrba);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int     result;
int(64) .ext extrba;
result := GET_EXTRBA(extrba);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result S9(4) COMP.
01 extrba S9(16) COMP.
ENTER C "GET_EXTRBA" using &amp;extrba giving result.
</pre>
<dl>
<dt><code>extrba</code></dt>
<dd>
<p>The current position in the Oracle GoldenGate trail.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i966461"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_EXTSEQNO</h2>
<p>Gets the sequence number for the current Oracle GoldenGate trail.</p>
<p class="titleinrefsubsect"><a id="sthref1742"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
long     seqno;
short    result;
result = GET_EXTSEQNO(&amp;extseqno);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int     result;
int(32) .ext seqno;
result := GET_EXTSEQNO(seqno) ;
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result     PIC S9(4) COMP.
01 seqno      PIC S9(4) COMP.
ENTER C "GET_EXTSEQNO" using seqno giving result.
</pre>
<dl>
<dt><code>seqno</code></dt>
<dd>
<p>The sequence number of the Oracle GoldenGate trail file.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="e935422"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_FILENAME</h2>
<p>Retrieves the source or target file name.</p>
<p class="titleinrefsubsect"><a id="sthref1743"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short result;
typedef struct fname_def
{char volume[8];
  char subvol[9];
  char file[8];
} fname_def;
fname_def fname;
short source_or_target;
result = GET_FILENAME(fname, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext fname;
int source_or_target;
result :=  GET_FILENAME (fname,  source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result     PIC S9(4) COMP2.
01 fname.
  02 volume   pic x(8).
  02 subvol   pic x(8).
  02 filename pic x(8).
01 source-or-target PIC S9(4) COMP.
ENTER C "GET_FILENAME" using fname, source-or-target giving result.
</pre>
<dl>
<dt><code>filename</code></dt>
<dd>
<p>The name of the current record's file.</p>
</dd>
<dt><code>fname</code></dt>
<dd>
<p>The name of the file in internal format.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether the record is a source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i968480"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_FOPEN_NUM</h2>
<p>Returns the open number for the file.</p>
<p class="titleinrefsubsect"><a id="sthref1744"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    result;
short    fopen_num;
result = GET_FOPEN_NUM(&amp;fopen_num);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int  result;
int  .ext fopen_num;
result :=  GET_FOPEN_NUM (fopen_num);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result    PIC S9(4) COMP.
01 fopen-num PIC S9(4) COMP.
ENTER C "GET_FOPEN_NUM" using fopen-num giving result.
</pre>
<dl>
<dt><code>fopen_num</code></dt>
<dt><code>fopen-num</code></dt>
<dd>
<p>The number assigned to the file by the process opening it.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dd>
<p>Indicates whether to retrieve the source or target file name.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i966839"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_NUM_COLUMNS</h2>
<p><code>GET_NUM_COLUMNS</code> returns the number of columns in an SQL table. Use this information when processing compressed and decompressed records.</p>
<p class="titleinrefsubsect"><a id="sthref1745"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    num_columns;
short    source_or_target;
short    result;
result = GET_NUM_COLUMNS (&amp;num_columns, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect 
int     result;
int     .ext num_columns;
int     source_or_target;
result := GET_NUM_COLUMNS (num_columns, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 num-columns      PIC S9(4) COMP.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "GET_NUM_COLUMNS" using num-columns, source-or-target
         giving result.
</pre>
<dl>
<dt><code>num_columns</code></dt>
<dt><code>num-columns</code></dt>
<dd>
<p>The number of columns in the SQL table.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Indicates whether to retrieve number of columns for the source or target table.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i935455"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_RECORD | GET_RECORD2</h2>
<p>Data mapping from a source to a different target format is often required when extracting or replicating data. Although the <code>COLMAP</code> specification supported by both Replicat and Extract works sufficiently for most, user exits may be necessary for some field conversions.</p>
<p>Extract and Replicat pass data records to the exit after converting to the target format. In the event that a few fields do not convert, <code>GET_RECORD</code> and <code>GET_RECORD2</code> provide a way to obtain information for custom field conversions. For example, an exit could convert a proprietary date field (such as <code>YYDDD</code>) in an Enscribe database to a standard SQL date in the target record, while other columns would be mapped by Extract.</p>
<p><code>GET_RECORD</code> is only valid for use with record less than 32767. <code>GET_RECORD2</code> is valid for both these smaller records and the longer records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1746"></a>Formats</p>
<p>Deletes, inserts and updates appear in the buffer as full record images. For SQL tables, this is the same format as produced by an <code>INVOKE</code> of the table.</p>
<p class="titleinrefsubsect"><a id="sthref1747"></a>Compressed SQL updates</p>
<p>Compressed SQL updates have the format:</p>
<pre>
<span class="codeinlineitalic">index</span> <span class="codeinlineitalic">length</span> <span class="codeinlineitalic">value</span> <span class="codeinlineitalic">index</span> <span class="codeinlineitalic">length</span> <span class="codeinlineitalic">value</span>&hellip;
</pre>
<p>Where:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">index</span></code> is a two byte index into the list of columns of the table (first column is zero).</p>
</li>
<li>
<p><code><span class="codeinlineitalic">length</span></code> is the two byte length of the table.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">value</span></code> is the actual column value, including when applicable a two byte null indicator (<code>0</code> for not null, <code>-1</code> for null).</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref1748"></a>Compressed Enscribe updates</p>
<p>Compressed Enscribe updates have the format:</p>
<pre>
<span class="codeinlineitalic">offset</span> <span class="codeinlineitalic">length</span> <span class="codeinlineitalic">value</span> <span class="codeinlineitalic">offset</span> <span class="codeinlineitalic">length</span> <span class="codeinlineitalic">value</span>
</pre>
<p>Where:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">offset</span></code> is the offset into the Enscribe record of the data fragment that changed.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">length</span></code> is the length of the fragment and value is the actual data. Fragments can span field boundaries, so full fields are not always retrieved (unless compression is off or <code>FETCHCOMPS</code> is elected).</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref1749"></a>Compressed Primary Key Updates</p>
<p>Compressed primary key updates contain three parts:</p>
<ul>
<li>
<p>The before-image key length</p>
</li>
<li>
<p>The before-image key value in field comp format</p>
</li>
<li>
<p>The after-image in field comp format</p>
</li>
</ul>
<p>You can modify the record keeping the format intact, or use <code>DECOMPRESS_RECORD</code> and <code>COMPRESS_RECORD</code> to obtain a full record format. To use the callback functions, you will need to separate the before and after-images and use the callback on only one portion at a time.</p>
<p>Use the following to move the record pointer so that you can manipulate the before-image up to the <code>before_len</code>. Note that the size of key length fields must be a <code>long</code>.</p>
<pre>
long before_len;
long after_len;
char *rec_ptr;
memcpy (&amp;before_len, rec, sizeof(before_len));  /* get before len */
rec_ptr = rec + sizeof (before_len);   /* move rec_ptr passed len */
</pre>
<p>For the after-image, use the following to manipulate the after-image up to the after_len.:</p>
<pre>
rec_ptr += before_len;
after_len = exit_params-&gt;record_len - sizeof (before_len) - before_len;
</pre>
<p>To see an example of the trail record with its before and after-images, use Logdump with the <code>Detail</code> option set on.</p>
<p class="titleinrefsubsect"><a id="sthref1750"></a>Syntax GET_RECORD</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *buf;
short    len;
short    io_type;
short    source_or_target;
short    result;
result = GET_RECORD (buf, &amp;len, &amp;io_type, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext buf;
int    .ext len;
int    .ext io_type;
int    source_or_target;
result := GET_RECORD (buf, len, io_type, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 buf              PIC X(32767).
01 len              PIC S9(4) COMP.
01 io-type          PIC S9(4) COMP.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "GET_RECORD" using buf, len, io-type, source-or-target
                     giving result.
</pre>
<dl>
<dt><code>buf</code></dt>
<dd>
<p>The record buffer for data returned by the Extract or Replicat programs. The memory for this buffer must be allocated by the user. Up to <code>X(32767)</code> can be used for the buffer.</p>
</dd>
<dt><code>io_type</code></dt>
<dt><code>io-type</code></dt>
<dd>
<p>Indicates the type of operation represented by the record, such as:</p>
<p><code>3</code> &mdash; Delete</p>
<p><code>5</code> &mdash; Insert</p>
<p><code>10</code> &mdash; Update</p>
<p><code>11</code> &mdash; Compressed Enscribe Update</p>
<p><code>15</code> &mdash; Compressed SQL Update</p>
<p><code>115</code> &mdash; Compressed primary key Update</p>
</dd>
<dt><code>len</code></dt>
<dd>
<p><code>LEN</code> is the length of the data returned in <code>BUF</code>.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether to retrieve the source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
<p class="titleinrefsubsect"><a id="sthref1751"></a>Syntax GET_RECORD2</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *buf;
long    len;
short    io_type;
short    source_or_target;
short    result;
result = GET_RECORD2 (buf, &amp;len, &amp;io_type, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext buf;
int(32).ext len;
int    .ext io_type;
int    source_or_target;
result := GET_RECORD2 (buf, len, io_type, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 buf              PIC X(128000).
01 len              PIC S9(8) COMP.
01 io-type          PIC S9(4) COMP.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "GET_RECORD2" using buf, len, io-type, source-or-target
                     giving result.
</pre>
<dl>
<dt><code>buf</code></dt>
<dd>
<p>The record buffer for data returned by the Extract or Replicat programs. The memory for this buffer must be allocated by the user. Up to <code>X(128000)</code> can be used in the buffer as long as it is declared in extended storage.</p>
</dd>
<dt><code>io_type</code></dt>
<dt><code>io-type</code></dt>
<dd>
<p>Indicates the type of operation represented by the record, such as:</p>
<p><code>3</code> &mdash; Delete</p>
<p><code>5</code> &mdash; Insert</p>
<p><code>10</code> &mdash; Update</p>
<p><code>11</code> &mdash; Compressed Enscribe Update</p>
<p><code>15</code> &mdash; Compressed SQL Update</p>
<p><code>115</code> &mdash; Compressed primary key Update</p>
</dd>
<dt><code>len</code></dt>
<dd>
<p><code>LEN</code> is the length of the data returned in <code>BUF</code>.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether to retrieve the source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i935484"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_RECORD_LENGTH | GET_RECORD_LENGTH2</h2>
<p>When returning control to Extract or Replicat, user exits are responsible for setting the length of the target record if and when mapping occurs. Use <code>GET_RECORD_LENGTH</code> or <code>GET_RECORD_LENGTH2</code> to obtain this value when the mapped record is not compressed. Set the <code>EXIT-PARAMS</code> structure member <code>RECORD-LENGTH</code> to this value.</p>
<p><code>GET_RECORD_LENGTH2</code> is only valid for use with records less than 32767. <code>GET_RECORD_LENGTH2</code> is valid for both these smaller records and the longer records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1752"></a>Syntax GET_RECORD_LENGTH</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    record_length;
short    source_or_target;
short    result;
result = GET_RECORD_LENGTH (&amp;record_length, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int     result;
int     .ext record_length;
int     source_or_target;
result := GET_RECORD_LENGTH(record_length,  source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 record-length    PIC S9(4) COMP.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "GET_RECORD_LENGTH" using record-length, source-or-target
         giving result.
</pre>
<dl>
<dt><code>record_length</code></dt>
<dt><code>record-length</code></dt>
<dd>
<p>The record length as calculated internally by Extract or Replicat.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether to retrieve the source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
<p class="titleinrefsubsect"><a id="sthref1753"></a>Syntax GET_RECORD_LENGTH2</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
long    record_length;
short    source_or_target;
short    result;
result = GET_RECORD_LENGTH2 (&amp;record_length, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int     result;
int(32) .ext record_length;
int     source_or_target;
result := GET_RECORD_LENGTH2(record_length,  source_or_target);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 record-length    PIC S9(8) COMP.
01 source-or-target PIC S9(4) COMP.
01 result           PIC S9(4) COMP.
ENTER C "GET_RECORD_LENGTH2" using record-length, source-or-target
         giving result.
</pre>
<dl>
<dt><code>record_length</code></dt>
<dt><code>record-length</code></dt>
<dd>
<p>The record length as calculated internally by Extract or Replicat.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether to retrieve the source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i939962"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_SYSKEY_LENGTH</h2>
<p>Returns the length of <code>SYSKEY</code> for the current record.</p>
<p class="titleinrefsubsect"><a id="sthref1754"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
include "usrdecs"
short   syskeylen, 
short   source_or_target;
short   result;
result = GET_SYSKEY_LENGTH(&amp;syskey_len, source_or_target);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int  result;
int  .ext syskeylen;
int  source_or_target;
result := GET_SYSKEY_LENGTH (syskeylen, source_or_target) ;
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result           PIC S9(4) COMP.
01 syskeylen        PIC S9(4) COMP.
01 source_or_target PIC S9(4) COMP.
ENTER C "GET_SYSKEY_LENGTH" using syskeylen, source-or-target 
         giving result.
</pre>
<dl>
<dt><code>syskeylen</code></dt>
<dd>
<p>The length of the system key.</p>
</dd>
<dt><code>source_or_target</code></dt>
<dt><code>source-or-target</code></dt>
<dd>
<p>Represented by either <code>EXIT-FN-SOURCE-VAL</code> or <code>EXIT-FN-TARGET-VAL</code> to indicate whether to retrieve the source or target record.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i935512"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_TRANSACTION_IND</h2>
<p>Knowing whether a data record is the first, last or middle operation in a transaction can prove useful to an exit routine. For example, an exit might want to compile the details of each transaction and output a special summary record at the end. This type of processing is accommodated by <code>GET_TRANSACTION_IND</code>.</p>
<p class="titleinrefsubsect"><a id="sthref1755"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short result;
short trans_ind;
result = GET_TRANSACTION_IND (&amp;trans_ind);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext trans_ind;
result := GET_TRANSACTION_IND (trans_ind);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result    PIC S9(4) COMP.
01 trans-ind PIC S9(4) COMP.
ENTER C "GET_SOURCE_RECORD" using trans-ind giving result.
</pre>
<dl>
<dt><code>trans_ind</code></dt>
<dt><code>trans-ind</code></dt>
<dd>
<p>Indicates whether the current record is the first (<code>0</code>), middle (<code>1</code>), last (<code>2</code>), or both first and last (<code>3</code>) record in a transaction.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i977439"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GET_USER_TOKEN_VALUE</h2>
<p><code>GET_USER_TOKEN_VALUE</code> allows the user exit to retrieve the value of user tokens.</p>
<p class="titleinrefsubsect"><a id="sthref1756"></a>Buffers</p>
<p><span class="syntaxinlinebold">xlibc</span></p>
<pre>
typedef struct __user_token_value {
   char   token_name[256];
   short  actual_length;
   char   token_value_buf[2000];
} user_token_vaue_def;
</pre>
<p><span class="syntaxinlinebold">xlibcob</span></p>
<pre>
01 result native-2.
?Section TOKENS,Tandem
  01 USER-TOKEN-VALUE.
    02 TOKEN-NAME PIC X(256).
    02 ACTUAL-LENGTH NATIVE-2.
    02 TOKEN-VALUE-BUF PIC X(2000).
</pre>
<p class="titleinrefsubsect"><a id="sthref1757"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
#include "xlibc"
short result = 0;
user_token_value_def usr_token_val;
result = GET_USER_TOKEN_VALUE (&amp;usr_token_val);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
int .ext utoken_value_ptr(user_token_value_def);
result := GET_USER_TOKEN_VALUE(utoken_value_ptr); 
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?ENV COMMON
?CONSULT =EXTRACT (or =REPLICAT)

ENTER C "GET_USER_TOKEN_VALUE" using USER-TOKEN-VALUE giving RESULT. 
</pre>
<p class="titleinrefsubsect"><a id="sthref1758"></a>Return Values</p>
<pre>
EXIT_FN_RET_OK
EXIT_FN_RET_INVALID_CONTEXT
EXIT_FN_RET_TOKEN_NOT_FOUND
</pre>
<dl>
<dt><code>token_name</code></dt>
<dt><code>TOKEN-NAME</code></dt>
<dd>
<p>Up to 256 characters to specify the name of the user token.</p>
</dd>
<dt><code>actual_length</code></dt>
<dd>
<p>The actual length of the data returned in the buffer.</p>
</dd>
<dt><code>token_value_buf</code></dt>
<dd>
<p>The 2000 byte buffer that will receive data.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not. One of the following:</p>
<pre>
EXIT_FN_RET_OK
EXIT_FN_RET_INVALID_CONTEXT
EXIT_FN_RET_TOKEN_NOT_FOUND
</pre></dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i977237"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GGS_EMSMESSAGE</h2>
<p><code>GGS_EMSMESSAGE</code> allows a user exit to write a message to the EMS log file. The message will have the Oracle GoldenGate subsystem ID.</p>
<p class="titleinrefsubsect"><a id="sthref1759"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short result;
int   evtnum;
int   severity;
char  *text;
result = GGS_EMSMESSAGE(int evtnum, text, severity);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int    result;
int    evtnum;
string .ext text;
int    severity;
result := GGS_EMSMESSAGE(evtnum, text, severity);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 evtnum        PIC S(4) COMP.
01 result        PIC S(4) COMP.
01 text          PIC X(132).
01 severity      PIC S(4) COMP.
ENTER C "GGS_EMSMESSAGE" using evtnum, text, severity giving result.
</pre>
<dl>
<dt><code>evtnum</code></dt>
<dd>
<p>An arbitrary number used to identify a message.</p>
</dd>
<dt><code>text</code></dt>
<dd>
<p>The text of the message.</p>
</dd>
<dt><code>severity</code></dt>
<dd>
<p>A value that identifies how severe the message is, as in:</p>
<ul>
<li>
<p><code>MSG_INFO 1</code> &mdash; normal EMS message.</p>
</li>
<li>
<p><code>MSG_CRITICAL 2</code> &mdash; EMS message with emphasis set to <code>ON</code>.</p>
</li>
<li>
<p><code>MSG_FATAL 3</code> &mdash; abends the process after writing the message.</p>
</li>
</ul>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="i947082"></a>
<hr />
<div class="refsect1">
<h2 class="refsect1">GGS_REPORTMESSAGE</h2>
<p>Allows a user exit to write a message to the report file.</p>
<p class="titleinrefsubsect"><a id="sthref1760"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
short    result;
char    text[132];
result = GGS_REPORTMESSAGE(&amp;text);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int result;
string .ext text;
result := GGS_REPORTMESSAGE(text) ;
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 result PIC S9(4) COMP.
01 text   PIC X(132).
ENTER C "GGS_REPORTMESSAGE" using text giving result.
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<p>The string value in message text must be null terminated.</p>
</div>
<dl>
<dt><code>text</code></dt>
<dd>
<p>The text of the message.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="BABJIFFD"></a>
<hr />
<div class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">SET_TARGET_RECORD2</h2>
<p>Use <code>SET_TARGET_RECORD2</code> to set the values of a modified record. This step is not required for the buffers under 32 K, but is required for larger records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1761"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
char     *buf;
long     record_len;
short    io_type;
short    result;
result = SET_TARGET_RECORD2 (buf, &amp;record_len, &amp;io_type);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
string  .ext buf;
int(32) len;
int     io_type;
int     result;
result := SET_TARGET_RECORD2 (buf, len, io_type);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 buf       PIC X(128000).
01 len       PIC S9(8) COMP.
01 io-type   PIC S9(4) COMP.
01 result    PIC S9(4) COMP.
ENTER C "SET_TARGET_RECORD2" using buf, len, io-type giving result.
</pre>
<dl>
<dt><code>buf</code></dt>
<dd>
<p>The record buffer for data returned by the Extract or Replicat programs. The memory for this buffer must be allocated by the user. Up to <code>X(127000)</code> can be used in the buffer as long as it is declared in extended storage.</p>
</dd>
<dt><code>len</code></dt>
<dd>
<p><code>LEN</code> is the length of the data returned in <code>BUF</code>.</p>
</dd>
<dt><code>io_type</code></dt>
<dt><code>io-type</code></dt>
<dd>
<p>Indicates the type of operation represented by the record, such as:</p>
<p><code>3</code> &mdash; Delete</p>
<p><code>5</code> &mdash; Insert</p>
<p><code>10</code> &mdash; Update</p>
<p><code>11</code> &mdash; Compressed Enscribe Update</p>
<p><code>15</code> &mdash; Compressed SQL Update</p>
<p><code>115</code> &mdash; Compressed primary key Update</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" -->
<a id="BABHHGBE"></a>
<hr />
<div class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">SET_TARGET_RECORD_LENGTH2</h2>
<p>Use <code>SET_TARGET_RECORD_LENGTH2</code> to set the length of a modified target record. This step is not required for the smaller records defined with DDL, but is required for large records defined with DDL2.</p>
<p class="titleinrefsubsect"><a id="sthref1762"></a>Syntax</p>
<p><span class="syntaxinlinebold">For C:</span></p>
<pre>
#include "usrdecs"
long     record_len;
short    result;
result = SET_TARGET_RECORD_LENGTH2 (&amp;record_len);
</pre>
<p><span class="syntaxinlinebold">For TAL:</span></p>
<pre>
?source usrdect
int(32) record_len;
int     io_type;
int     result;
result := SET_TARGET_RECORD_LENGTH2 (record_len);
</pre>
<p><span class="syntaxinlinebold">For COBOL:</span></p>
<pre>
?CONSULT =EXTRACT (or =REPLICAT)
01 record-len  PIC S9(8) COMP.
01 result      PIC S9(4) COMP.
ENTER C "SET_TARGET_RECORD_LENGTH2" using record-length giving result.
</pre>
<dl>
<dt><code>record_len</code></dt>
<dt><code>record-len</code></dt>
<dd>
<p>The record length as calculated internally by Extract or Replicat.</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>A code indicating whether the call was successful or not.</p>
</dd>
</dl>
</div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment10">
<tr>
<td class="cellalignment17">
<table class="cellalignment15">
<tr>
<td class="cellalignment14"><a href="measfls_measrpt_parameters.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment14"><a href="event_messages.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1995, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment19">
<table class="cellalignment13">
<tr>
<td class="cellalignment14"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment14"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
